---
layout: post
title: Making ideas real
location: New York, NY, USA
excerpt: Ideas are short-lived. Everyone gets excited about the idea quick, but by the time it gets released most might not even remember anymore why. I think there is value in immediacy. No matter if it is an extra table or a brand new project.
---

Ideas are short-lived. Everyone gets excited about the idea quick, but by the time it gets released most might not even remember anymore why. I think there is value in immediacy. No matter if it is an extra table or a brand new project.

Wireframing and prototyping are great skills to have. It’s hard to visualize concepts and abstract ideas. They also lead to difficult conversations. But once that idea is real, it’s much easier to reason about it and take it further. This is why 3D printing is so exciting and is transforming a lot of environments where physical examples used to take forever. In software 3D printers are all the frameworks and libraries providing great functionality out of the box.

Controversially the [waterfall model](http://en.wikipedia.org/wiki/Waterfall_model) is perfect for kicking things off. Agile starts a few weeks in. Starting a project and not knowing where it is going to end, only caring about this week’s tasks, makes it harder to focus. Ideally there should be some balance between the two, but the more you know upfront, the easier it will be to deliver. Everyone figures out what are they key features to have, how are they going to behave and comes up with a list of tasks. Once done with the exercise everyone has a clear direction and thus have enough information to proceed.

This needs to happen even if you are working alone. Having a vague idea like *”I want to build an iPhone app which tracks my heath”* and then hacking towards it is not specific enough. It helps to know what are the exact steps to a finished product. While it might look unnecessary, having the [discipline](/blog/comfort-kills-creativity.html) to properly manage the project works wonders. I find that not doing so leaves to a lot of unfinished projects, as it’s hard to keep pushing when you have no idea where the finish line is.

I like [Impact Mapping](http://www.impactmapping.org/) approach for this. Instead of describing tasks on the functionality-level, it provides context. Why everything is getting done and how it will impact other things. Just writing it out will reveal a lot of drawbacks in the thinking. Once complete, everyone working on a project will have a much better understanding of what is really happening. A lot of organizations have a one-way approach to this. The management comes up with requirements and then passes them along to the developers. This often doesn’t work well. Have the developers in the conversation and everyone focused on the impact of the ideas instead. Let them figure out how to do it best.

Every atomic feature should be shippable in under a day. If it can’t, split it into smaller features. If it looks hard and it’s hard to tell how long it will take, split it too. If the whole list looks too long, remove non essential ones. Simplify, divide and conquer. This avoids days of isolated work and enables fast iterations.

> Wiggins' Law: If it's hard, cut scope.

Often projects will drag on for longer because unforeseen reasons complicate the feature. I’ve seen this happen mostly when it comes to talking to external systems. Fake the interaction and table it for now, it can wait. Keep moving.

If the first feature you want to have is a login functionality and you think it will take more than an hour, something is not right. This is not the time to try new technologies. Instead having a toolbox of technologies to pick from is best. It can all be changed later. The goal is to get to the point when one can start adding *real* features. Thus [Bootstrap](http://getbootstrap.com/css/) to me is the single most important project. Before that, a lot of people including myself were struggling to make apps which looked great. Now even the simple things look usable and work on any platform.

It has to look pretty. Everyone has their own area they like to spend some extra time on, mine is making sure everything is pixel perfect. It just *feels good* to work on something that looks polished. Not only that, I can show it to other people. Remember the faked interaction with an external system? No one will be able to tell. Design is key. It doesn’t stop at just graphics, thinking about the way it will all work will also help shape other things.

Once done a feature should go out to the live environment immediately. [Nothing is real until it's being used by a real user.](https://gist.github.com/adamwiggins/5687294) The goal is to have at least one release every day. The setup also needs to be part of the starting toolbox. A lot of things break in interesting ways in production. Facebook used to say *“Move fast and break things”*, they are too big now to do that anymore. The underlying idea behind this is that it is easier to test and fix things when released in small iterations. As opposed to cooking something for a week and then figuring out which of the 15 new features broke. It’s important not to forget that most work does not involve working on rockets. Even when broken it will not have catastrophic results.

Achieving smooth release requires automated tests. Otherwise there is no way to check if the deliverable works. I don’t find writing tests beforehand beneficial since a lot of features end up materializing as they get worked on. It requires thinking about too much low-level detail, the focus instead should be on tangible things. Instead, playing around with different flows is faster and more natural. Once everything functions, though, everything gets thoroughly covered in tests. This *locks in* the behavior. Some people prefer to do this the other way round - great! Whatever works for you. I’ve tried going hardcore and just assuming everything will work, you might too if you think [TDD is dead](http://david.heinemeierhansson.com/2014/tdd-is-dead-long-live-testing.html). But sooner or later things start breaking the moment you move something and the process slows down.

And so it goes, small iterations of simple features and sooner or later the whole thing comes together. If it went well, it got done quickly and without too much going back and forward.
